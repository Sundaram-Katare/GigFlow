# GigFlow 
### GigFlow is a mini-freelance marketplace platform. The goal is to build a system where Clients can post jobs (Gigs) and Freelancers can apply for them (Bids).

# Tech Stack
- **Frontend** - React.js(vite) + TailwindCSS + Redux Toolkit
- **Backend** - Node + Express + JWT(for Authentication) + Socket.io
- **Database** - MongoDB
- **Tools** - `Postman` for the endpoints testing, `vercel` for the frontend deployment & `Render` for the backend deployment.

# Folder Structure

```bash
GIGFLOW/
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ db.js
â”‚   â”‚
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ authController.js
â”‚   â”‚   â”œâ”€â”€ bidController.js
â”‚   â”‚   â”œâ”€â”€ gigController.js
â”‚   â”‚   â””â”€â”€ userController.js
â”‚   â”‚
â”‚   â”œâ”€â”€ middlewares/
â”‚   â”‚   â””â”€â”€ authMiddleware.js
â”‚   â”‚
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ bidModel.js
â”‚   â”‚   â”œâ”€â”€ gigModel.js
â”‚   â”‚   â””â”€â”€ userModel.js
â”‚   â”‚
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ authRoutes.js
â”‚   â”‚   â”œâ”€â”€ bidRoutes.js
â”‚   â”‚   â”œâ”€â”€ gigRoutes.js
â”‚   â”‚   â””â”€â”€ userRoutes.js
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ generateToken.js
â”‚   â”‚   â””â”€â”€ verifyToken.js
â”‚   â”‚
â”‚   â”œâ”€â”€ .env
â”‚   â”œâ”€â”€ .env.example
â”‚   â”œâ”€â”€ .gitignore
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ package-lock.json
â”‚   â””â”€â”€ server.js
â”‚
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ public/
â”‚   â”‚
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ assets/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ features/
â”‚   â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”‚   â””â”€â”€ bid/
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ store/
â”‚   â”‚   â”‚   â””â”€â”€ store.js
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ App.css
â”‚   â”‚   â”œâ”€â”€ App.jsx
â”‚   â”‚   â”œâ”€â”€ index.css
â”‚   â”‚   â”œâ”€â”€ main.jsx
â”‚   â”‚   â””â”€â”€ socket.js
â”‚   â”‚
â”‚   â”œâ”€â”€ .gitignore
â”‚   â”œâ”€â”€ eslint.config.js
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ package-lock.json
â”‚   â”œâ”€â”€ postcss.config.js
â”‚   â”œâ”€â”€ README.md
â”‚   â””â”€â”€ tailwind.config.js
â”‚
â””â”€â”€ README.md
```

# Backend Architecture and Endpoints
1. **Auth Routes**:- 
     - POST `/register` = For user registration.
     - POST `/login` = for user login
     - POST `/logout` = for user logout

2. **User Routes**:-
     - GET `/profile` = to fetch user's profile

3. **Gig Routes**:-
    - **POST** `/addGig` â€” Create a new gig (requires authentication).
    - **GET** `/getAllGigs` â€” Retrieve all gigs available.
    - **GET** `/getAllGigsOfSingleUser` â€” Get gigs created by the logged-in user.
    - **PUT** `/updateStatus/:id` â€” Update the status of a specific gig by ID (requires authentication).
    - **GET** `/getAllBids` â€” Fetch all bids placed on gigs (requires authentication).

4. **Bid Routes**:-
    - **POST** `/addBid` â€” Create a new bid on a gig (requires authentication).
    - **PUT** `/hireBid` â€” Hire/accept a specific bid for a gig (requires authentication).

### Database Models
<img width="1536" height="1024" alt="image" src="https://github.com/user-attachments/assets/550dd775-b2b8-4e6f-8018-b893463db819" />

# Key Functionalities:-
 - 2 roles for the users either `freelancer` or `client`.
 
 - LoggedIn user can see all `gigs` generated by him and all the `bids` made on that gig.
 
 - When user `hire` a bid, then all the other bids get `rejected` authomatically, also, the status of that gig become from `open` to `assigned` â¬‡ï¸
 
    <img width="321" height="215" alt="image" src="https://github.com/user-attachments/assets/d9b0aaec-8475-4614-aa6a-563d7371afd9" />

 - User will get 'toast` messages, when they add a gig or bid over any gig.
 
 - Real time notification will send to the user when he is `hired` or `rejected`
 <img width="321" height="215" alt="image" src="https://github.com/user-attachments/assets/400ab59b-8ede-4188-b43c-4fdb3baa828b" />


 - Public feed to browse the jobs + search functionality(to search gigs by their title)
 <img width="321" height="215" alt="image" src="https://github.com/user-attachments/assets/ee9ec151-f9fd-4237-bbd8-6885e4f1fc4b" />

 

# UI Preview
<img width="1898" height="916" alt="Screenshot 2026-01-13 111604" src="https://github.com/user-attachments/assets/6cbdd0fb-c491-4e68-8dd0-d89470966c21" />

# Local Setup
1. Fork the repo

2. Clone it
```bash
  git clone repo_url
```

3. Install frontend Dependencies
```bash
  cd frontend
  npm install
```

4. Install Backend Dependencies
```bash
  cd ..
  cd backend
  npm install
```

5. Setup `.env` from `.env.example`

6. Run frontend
```bash
  npm run dev
```

7. Run Backend
```bash
  node server.js
```  

# .env Examples

**Frontend**
```bash
 VITE_API_URL="http://localhost:5000/api"
 VITE_SOCKET_URL="http://localhost:5000"
```

**backend**
```bash
 PORT=5000
 MONGO_URI="your_mongodb_connection_string"
 JWT_SECRET="your_jwt"
 FRONTEND_URL="http://localhost:5173"
 NODE_ENV="development"
```

# Future Improvements
- Add a chatbot feature so that client and freelancer can communicate with each other to discuss about the deal.
- Points based rankings or gamification of the platform.
- More filters for the gigs based on price, category, date posted, etc.

# Transaction Integrity
```bash
/**
 * Secure hire function using MongoDB transactions with notifications for hired and rejected bidders
 */
const hireBid = async (req, res) => {
    try {
        const { bidId } = req.body;

        if (!bidId) {
            return res.status(400).json({ message: 'Bid ID is required' });
        }

        let gigOwner = null;
        let hiredFreelancer = null;
        let gigTitle = null;
        let rejectedBidUserIds = [];

        // Execute the entire hire operation as a transaction
        const result = await executeTransaction(async (session) => {
            // 1. Fetch the bid with the session to ensure read consistency
            const bid = await Bid.findById(bidId)
                .populate('gigId')
                .populate('userId')
                .session(session);

            if (!bid) {
                throw new Error('Bid not found');
            }

            if (bid.status !== 'pending') {
                throw new Error(`Bid status is ${bid.status}, only pending bids can be hired`);
            }

            // 2. Fetch the gig with the session
            const gig = await Gig.findById(bid.gigId._id)
                .populate('userId')
                .session(session);

            if (!gig) {
                throw new Error('Gig not found');
            }

            // 3. Critical check: Ensure gig is still in 'open' status
            if (gig.status !== 'open') {
                throw new Error('This gig has already been assigned to another freelancer');
            }

            if (gig.hiredFreelancerId && gig.hiredFreelancerId.toString() !== bid.userId._id.toString()) {
                throw new Error('Another freelancer has already been hired for this gig');
            }

            // Store data for notifications after transaction
            gigOwner = gig.userId;
            hiredFreelancer = bid.userId;
            gigTitle = gig.title;

            // 4. Get all rejected bids before updating them (to notify users later)
            const rejectedBids = await Bid.find({ 
                gigId: bid.gigId._id,
                _id: { $ne: bidId },
                status: 'pending'
            }).session(session);

            // Extract user IDs of rejected bidders
            rejectedBidUserIds = rejectedBids.map(b => b.userId.toString());

            // 5. Update the bid to 'hired' status with timestamp
            const hiredBid = await Bid.findByIdAndUpdate(
                bidId,
                { 
                    status: 'hired',
                    hiredAt: new Date()
                },
                { new: true, session }
            );

            // 6. Update the gig to 'assigned' status and set the hired freelancer
            const updatedGig = await Gig.findByIdAndUpdate(
                bid.gigId._id,
                { 
                    status: 'assigned',
                    hiredFreelancerId: bid.userId._id,
                    $inc: { version: 1 }
                },
                { new: true, session }
            );

            // 7. Reject all other bids for this gig
            const rejectionResult = await Bid.updateMany(
                { 
                    gigId: bid.gigId._id,
                    _id: { $ne: bidId },
                    status: 'pending'
                },
                { status: 'rejected' },
                { session }
            );

            return {
                bid: hiredBid,
                gig: updatedGig,
                rejectedCount: rejectionResult.modifiedCount
            };
        });

        // 8. After transaction commits, emit notifications to all affected users
        
        // Notify the hired freelancer
        if (hiredFreelancer && gigTitle) {
            emitHiredNotification(hiredFreelancer._id.toString(), {
                message: `ğŸ‰ Congratulations! You have been hired for "${gigTitle}"!`,
                projectName: gigTitle,
                bidId: bidId,
                gigId: result.gig._id
            });
        }

        // Notify the gig owner
        if (gigOwner && hiredFreelancer && gigTitle) {
            emitAssignedNotification(gigOwner._id.toString(), {
                message: `âœ… You have successfully hired ${hiredFreelancer.name} for "${gigTitle}"!`,
                freelancerName: hiredFreelancer.name,
                projectName: gigTitle,
                bidId: bidId,
                gigId: result.gig._id
            });
        }

        // Notify all rejected bidders
        if (rejectedBidUserIds.length > 0 && hiredFreelancer && gigTitle) {
            rejectedBidUserIds.forEach(userId => {
                emitRejectionNotification(userId, {
                    message: `âŒ Unfortunately, your bid for "${gigTitle}" was not selected. ${hiredFreelancer.name} has been hired for this project.`,
                    projectName: gigTitle,
                    bidId: bidId,
                    gigId: result.gig._id,
                    hiredFreelancerName: hiredFreelancer.name
                });
            });
        }

        return res.status(200).json({
            message: 'Freelancer hired successfully',
            data: result
        });

    } catch (error) {
        if (error.message.includes('already been assigned') || 
            error.message.includes('status is')) {
            return res.status(409).json({ 
                message: error.message,
                code: 'HIRE_CONFLICT'
            });
        }

        if (error.message === 'Bid not found' || error.message === 'Gig not found') {
            return res.status(404).json({ message: error.message });
        }

        return res.status(500).json({ 
            message: "Error hiring freelancer", 
            error: error.message 
        });
    }
}
```
